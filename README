Morelia ''viridis'' is a PythonLanguage BehaviorDrivenDevelopment platform, conceptually derived from RubyLanguage's CucumberFramework.

It is available, fully functional but with very little in the way of instructions, here: http://github.com/Phlip/Morelia/

To use it, first write a ''project.feature'' file, in ordinary prose, like this:

  http://cukes.info/images/feature.png

Note that "In order", "As a", and "I want" are not Morelia keywords. The other blue words are. The black words are executable test specifications.

Now create a ''standard'' PythonUnit test suite, like this:

  class Morelia''''''Test(TestCase):

    def setUp(self):
        self.stack = []

    def step_I_have_entered_a_number_into_the_calculator(self, number):
        r'I have entered (\d+) into the calculator'
        self.stack.append(int(number))

    def step_I_press_add(self):
        self.result = self.stack[0] + self.stack[1]

    def step_the_result_should_be_on_the_screen(self, number):
        "the result should be (\d+) on the screen"
        assert int(number) == self.result

Note that Morelia does not waste anyone's time inventing a new testing back-end just to add a layer of literacy over our testage. Steps are miniature TestCase''''''s.

Next, note that Morelia matches Steps in your Feature file to either the names or doc-strings of ''step_'' methods in your test case. And it expands regular expressions, such as (\d+), into step arguments, such as ''number''.

When you run your test case, hook into all your feature files, like this:

      def test_evaluate_file(self):
        from morelia import Parser
        Parser().parse_file('tests/morelia.feature').evaluate(self)

The passing steps will appear as passing test cases in your test run.

And note that Morelia calls ''setUp()'' and ''tearDown()'' around your Scenario. Each step calls within one TestCase, so ''self.'' can store variables between each step.

'''Tables'''

To DRY up a series of redundant scenarios, varying by only "payload" variables, roll the Scenarios up into a table, using <angles> around the payload variable names:

 Scenario: orders above $100.00 to the continental US get free ground shipping
   When we send an order totaling $<total>, with a 12345 SKU, to ProWares
    And the order will ship to <destination>
   Then the ground shipping cost is $<cost>
    And <rapid> delivery might be available

        |  total | destination            |  cost | rapid |

        | 101.00 | Rhode Island           |  0.00 |  yes  |
        |  99.00 | Kansas                 |  8.25 |  yes  |
        | 101.00 | Kansas                 |  0.00 |  yes  |
        |  99.00 | Hawaii                 |  8.25 |  yes  |
        | 101.00 | Hawaii                 |  8.25 |  yes  |
        | 101.00 | Alaska                 |  8.25 |  yes  |
        |  99.00 | Ontario, Canada        | 40.00 |   no  |
        |  99.00 | Brisbane, Australia    | 55.00 |   no  |
        |  99.00 | London, United Kingdom | 55.00 |   no  |
        |  99.00 | Kuantan, Malaysia      | 55.00 |   no  |
        | 101.00 | Tierra del Fuego       | 55.00 |   no  |

That Scenario will unroll into a series of scenarios, each with one value from the table inserted into their placeholders <total>, <destination>, and <rapid>. So this step method will receive each line in the "destination" column:

    def step_the_order_will_ship_to_(self, location):
        r'the order will ship to (.*)'

